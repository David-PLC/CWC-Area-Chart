<html lang="en-us">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Apex Chart</title>
  <link rel="icon" href="icon.png" />

  <script src="lib/jquery.min.js"></script>
  <script src="lib/apexcharts.min.js"></script>
  <link href="lib/apexcharts.css" rel="stylesheet">

  <script src="webcc.min.js"></script>
  <script src="unified.interface.js"></script>
  <link href="lib/style.css" rel="stylesheet">
  <script>
    var production = true;

    function init(result) {
      if (result) {
        unifiedInterfaceInit();
        chartInit(WebCC.Properties);
      } else {
        console.log('CWC_CWC_AreaChart: Init without result.');
      }
    }

    window.onload = function () {
      if (!production) {

        WebCC.Properties = {
          X_axis: [["2023-08-29T13:12:09", "2023-08-29T13:15:13", "2023-08-29T13:20:21", "2023-08-29T13:25:23", "2023-08-29T13:30:25", "2023-08-29T13:35:26", "2023-08-29T13:40:27"]],
          Y_axis: [[10, 25, 56, 9, 45, 25, 79]],
          SeriesColor: ["#EE730D"],
          DataName: ["Carriage power (Kw)"],
          X_axisname: 'Time',
          Y_axisname: 'Kw',
          SeriesLabels: true,
          LineType: 'Smooth',
          XAxisType: 'DateTime',
          ChartType: 'Line'
        };
        init(true);
      }
      if (production) {
        WebCC.start(init, UnifiedInterface.HostListener, _extensions, _timeout);
      }
    }
  </script>

</head>

<body>

  <div id="content">
    <div id="chart">
    </div>
  </div>


  <script>

    var chartInit = function (props) {
      // load and parse Xaxis
      if (props.hasOwnProperty('X_axis') && props.X_axis != null) {
        if (typeof props.X_axis === 'string') {
          console.log('CWC_AreaChart: props.Xaxis:' + props.X_axis);
          propsX_axis = JSON.parse(props.X_axis);
        } else if (Array.isArray(props.X_axis)) {
          propsX_axis = props.X_axis;
        } else {
          console.log('CWC_AreaChart: WRONG FORMAT: X_axis');
        }
      } else {
        return;
      }

      // load and parse Y_axis
      if (props.hasOwnProperty('Y_axis') && props.Y_axis != null) {
        if (typeof props.Y_axis === 'string') {
          console.log('CWC_AreaChart: props.Y_axis:' + props.Y_axis);
          propsY_axis = JSON.parse(props.Y_axis);
        } else if (Array.isArray(props.Y_axis)) {
          propsY_axis = props.Y_axis;
        } else {
          console.log('CWC_AreaChart: WRONG FORMAT: Y_axis');
        }
      } else {
        return;
      }

      // load and parse DataName
      if (props.hasOwnProperty('DataName') && props.DataName != null) {
        if (typeof props.DataName === 'string') {
          console.log('CWC_AreaChart: props.DataName:' + props.DataName);
          propsDataName = JSON.parse(props.DataName);
        } else if (Array.isArray(props.DataName)) {
          propsDataName = props.DataName;
        } else {
          console.log('CWC_AreaChart: WRONG FORMAT: DataName');
        }
      } else {
        return;
      }

      // load and parse SeriesColor
      if (props.hasOwnProperty('SeriesColor') && props.SeriesColor != null) {
        if (typeof props.SeriesColor === 'string') {
          console.log('CWC_AreaChart: props.SeriesColor:' + props.SeriesColor);
          propsSeriesColor = JSON.parse(props.SeriesColor);
        } else if (Array.isArray(props.SeriesColor)) {
          propsSeriesColor = props.SeriesColor;
        } else {
          console.log('CWC_AreaChart: WRONG FORMAT: SeriesColor');
        }
      } else {
        return;
      }

      // load and parse X_axisname
      if (props.hasOwnProperty('X_axisname') && props.X_axisname != null) {
        propsX_axisname = props.X_axisname
      }

      // load and parse Y_axisname
      if (props.hasOwnProperty('Y_axisname') && props.Y_axisname != null) {
        propsY_axisname = props.Y_axisname
      }

      // load and parse SeriesLabels
      if (props.hasOwnProperty('SeriesLabels') && props.SeriesLabels != null) {
        propsSeriesLabels = props.SeriesLabels
      }

      // load and parse LineType
      if (props.hasOwnProperty('LineType') && props.LineType != null) {
        propsLineType = props.LineType.toLowerCase();
      }

      // load and parse XAxisType
      if (props.hasOwnProperty('XAxisType') && props.XAxisType != null) {
        propsXAxisType = props.XAxisType.toLowerCase();
      }

      // load and parse ChartType
      if (props.hasOwnProperty('ChartType') && props.ChartType != null) {
        propsChartType = props.ChartType.toLowerCase();
      }

      if (chart.renderDone) {
        updateSeries(propsDataName, propsY_axis, propsX_axis, propsSeriesColor)
      } else {
        let xSeries = createSeries(propsDataName, propsY_axis, propsX_axis, propsSeriesColor);
        let options = creteOptions(xSeries, propsChartType, propsX_axisname, propsY_axisname, propsSeriesLabels, propsLineType, propsXAxisType);

        chart = new ApexCharts(document.querySelector("#chart"), options);
        chart.render().then(() => chart.renderDone = true);
      }
      WebCC.Properties.Render = false;
    }

    function createSeries(name, dataY, dataX, color) {
      let xSeries = [];
      for (let i = 0; i < name.length; i++) {
        let xValXY = [];
        let xData = {};
        xData['name'] = name[i];
        xData['color'] = color[i];
        for (let x = 0; x < dataY[i].length; x++) {
          let dataxy = {};
          dataxy['x'] = dataX[i][x];
          dataxy['y'] = dataY[i][x];
          xValXY.push(dataxy);
        }
        xData['data'] = xValXY;
        xSeries.push(xData);
      }
      console.log("CWC_AreaChart render:" + JSON.stringify(xSeries));
      return xSeries;
    }

    function updateSeries(name, dataY, dataX, color) {
      let xSeries = [];
      for (let i = 0; i < name.length; i++) {
        let xData = {};
        let xValXY = [];
        xData['name'] = name[i];
        xData['color'] = color[i];
        for (let x = 0; x < dataY[i].length; x++) {
          let dataxy = {};
          dataxy['x'] = dataX[i][x];
          dataxy['y'] = dataY[i][x];
          xValXY.push(dataxy);
        }
        xData['data'] = xValXY;
        xSeries.push(xData);
      }
      console.log("CWC_AreaChart update:" + JSON.stringify(xSeries));
      chart.updateSeries(xSeries, true);
    }


    function creteOptions(xSeries, chartType, XNames, YNames, xLabels, xLineType, xXAxisType) {
      let xoptions = {
        series: xSeries,
        chart: {
          type: chartType,
          width: '100%',
          height: '100%',
          fontFamily: 'Montserrat',
          zoom: {
            enabled: true
          }
        },
        dataLabels: {
          enabled: xLabels,
          textAnchor: 'start',
          formatter: function (val, opt) {
            return val + ''
          }
        },
        stroke: {
          curve: xLineType,
          lineCap: 'square',
        },
        xaxis: {
          type: xXAxisType,
          labels: {
            datetimeUTC: false
          },
          title: {
            text: XNames,
          },
        },
        yaxis: {
          title: {
            text: YNames,
          },
        },
        legend: {
          position: 'top',
          horizontalAlign: 'center',
          floating: true
        },
        tooltip: {
          x: {
            format: 'dd/MM/yyyy HH:mm:ss:fff'
          },
        }
      };
      return xoptions
    }

  </script>

</body>

</html>